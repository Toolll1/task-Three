## Serialization. Практика:
Создать список объектов типа "Человек" с полями имя, возраст и род деятельности. 
Данный список объектов должен быть сериализован в файл при помощи интерфейса Serializable, 
при этом поле род деятельности не должно сериализовываться - оно должно быть вычислимым. 
Соответственно при десериализации оно должно вычисляться (и заполняться в объектах) по 
следующему правилу: если человеку от 0 до 3 лет - он сидит дома, если человеку 
от 3 до 7 лет - ходит в детский сад, от 7 до 18 лет - учится в школе, 
от 17 до 23 - учится в институте, от 24 до 65 - работает, от 65 и выше - на пенсии.

## Java 8+. Практика:
Есть следующий код:

public class Developer {
private String name;
private List<String> languages;
//плюс геттеры и сеттеры
}

Developer dev1 = new Developer("Наташа", Arrays.asList("Java", "C++"));
Developer dev2 = new Developer("Эрнест", Arrays.asList("Java", "Python"));
Developer dev3 = new Developer("Элла", Arrays.asList("С#", "Python", "JavaScript"));
Stream<Developer> developerStream = Stream.of(dev1, dev2, dev3);

Задача - найти разработчиков с уникальными языками программирования, используя Stream API.
Для данного примера ожидаемый результат [Наташа, Элла].

 
## IO. Практика:
Реализовать файловый менеджер (в виде консольного приложения). На вход программе указывается 
абсолютный путь к файлу и ключ операции (с параметрами), которую необходимо выполнить над файлом. 
Должны быть реализованы операции создания файла, удаления, чтения, записи в файл. Учесть 
пограничные случаи и не забыть про удобную обработку исключений с выводом валидаций пользователю 
в консоль.

Пример вызова программы:
>>c:\\testdata\myfile.txt -create (создаст пустой файл)
или
>>c:\\testdata\myfile.txt -write "blablabla" (запишет в файл строку blablabla)


